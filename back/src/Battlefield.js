// Класс логически описывает поле с кораблями. Хранит корабли, выстрелы, раны.
module.exports = class Battlefield {
	// Корабли.
	ships = []
	// Выстрелы.
	shots = []

	/*
		Матрица игрового поля с отметками, на какие клетки можно ставить
		корабли, на какие нельзя, где уже есть раны или убийства.
	*/
	_private_matrix = null
	// Флаг - изменились ли корабли или выстрелы на матрице игрового поля?
	_private_changed = true

	// Флаг - проиграло поле или нет (убиты ли все корабли)?
	get loser () {
		// Пройти по всем кораблям на поле.
		for (const ship of this.ships) {
			// Если на поле есть хотя бы 1 неубитый корабль:
			if (!ship.killed) {
				// Данное игровое поле НЕ проиграло.
				return false
			}
		}

		// Если все корабли на поле убиты, поле проиграло.
		return true
	}

	/*
		Геттер возвращает матрицу игрового поля с отметками, на какие клетки
		можно ставить корабли, на какие нельзя, где уже есть раны или убийства.
		Если флаг _private_changed поднят, геттер возвращает новую матрицу.
		Если изменений нет - возвращает прежнюю.
	*/
	get matrix () {
		// Если изменений в матрице игрового поля нет:
		if (!this._private_changed) {
			return this._private_matrix
		}

		// Если изменения в матрице игрового поля есть:
		// Создать новую матрицу игрового поля.
		const matrix = []

		// Заполнение новой матрицы ячейками.
		for (let y = 0; y < 10; y++){
			const row = []

			for (let x = 0; x < 10; x++) {
				// Создание ячейки новой матрицы игрового поля.
				const item = {
					// Координаты ячейки.
					x,
					y,
					// Корабль в ячейке.
					ship: null,
					// Флаг - свободная ли ячейка?
					free: true,
					// Флаг - выстрелили ли в ячейку?
					shoted: false,
					// Флаг - ранена ли ячейка?
					wounded: false,
				}

				row.push(item)
			}

			matrix.push(row)
		}

		// Пройти по всем кораблям.
		for (const ship of this.ships) {
			// Если корабль ещё НЕ расположен на игровом поле:
			if (!ship.placed) {
				// Ничего не делать с этим кораблём.
				continue
			}

			// Координаты корабля.
			const { x, y } = ship
			// Флаг - расположен ли корабль на игровом поле горизонтально?
			const dx = ship.direction === 'row'
			// Флаг - расположен ли корабль на игровом поле вертикально?
			const dy = ship.direction === 'column'

			// Пройти по длине корабля.
			for (let i = 0; i < ship.size; i++) {
				// Координаты выбранной ячейки корабля.
				// Флаги dx, dy при умножении приводятся к 0 либо 1.
				const cx = x + dx * i
				const cy = y + dy * i

				// Ячейка матрицы, в которой должен быть корабль.
				const item = matrix[cy][cx]
				// Положить корабль в соответствующую ему ячейку матрицы.
				item.ship = ship
			}

			// Обозначение несвободными ячеек корабля и вокруг него.
			/*
				Пройти по строкам от строки над кораблем включительно
				до строки под кораблём включительно.
			*/
			for (let y = ship.y - 1; y < ship.y + ship.size * dy + dx + 1; y++) {
				/*
					Пройти по столбцам от столбца слева от корабля
					включительно до столбца справа от корабля включительно.
				*/
				for (let x = ship.x - 1;
					x < ship.x + ship.size * dx + dy + 1;
					x++ ) {
					/*
						Если выбранные координаты находятся
						в пределах игрового поля.
					*/
					if (this.inField(x, y)) {
						// Ячейка матрицы с выбранными координатами.
						const item = matrix[y][x]
						/*
							Обозначить ячейку несвободной
							(в неё нельзя ставить корабль).
						*/
						item.free = false
					}
				}
			}
		}

		// Пройти по координатам всех выстрелов.
		for (const { x, y } of this.shots) {
			// Ячейка с выбранными координатами выстрела.
			const item = matrix[y][x]
			// Отметить, что в эту ячейку уже выстрелили.
			item.shoted = true

			/*
				Если в ячейке с выбранными координатами выстрела
				находится корабль.
			*/
			if (item.ship) {
				// Отметить ячейку раненой.
				item.wounded = true
			}
		}

		// Присвоить матрице игрового поля значение новой матрицы.
		this._private_matrix = matrix
		this._private_changed = false
		return this._private_matrix
	}

	/*
		Флаг - готово ли поле игрока к бою
		(завершил ли игрок расстановку кораблей)?
	*/
	get complete () {
		// Если у игрока ещё НЕ полный комплект кораблей:
		if (this.ships.length !== 10) {
			// Поле игрока НЕ готово к бою.
			return false
		}

		// Если у игрока полный комплект кораблей:
		// Пройти по всем кораблям игрока.
		for (const ship of this.ships) {
			// Если выбранного корабля нет на поле:
			if (!ship.placed) {
				// Игрок не завершил расстановку кораблей.
				return false
			}
		}

		// Поле игрока готово к бою.
		return true
	}

	/*
		Метод определяет, находятся ли переданные координаты
		в пределах игрового поля.
	*/
	inField (x, y) {
		// Функция определяет, является ли переданное число числом.
		const isNumber = n =>
			parseInt(n) === n && !isNaN(n) && ![Infinity, -Infinity].includes(n)

		// Если хотя бы одна из координат не является числом:
		if (!isNumber(x) || !isNumber(y)) {
			// Координаты НЕ в пределах игрового поля.
			return false
		}

		// Если координаты находятся в нужном диапазоне, то они на игровом поле.
		return 0 <= x && x < 10 && 0 <= y && y < 10
	}

	/*
		Метод добавляет переданный корабль на поле на логическом уровне.
		Принимает координаты корабля.
		Возвращает true, если добавил, false - если НЕ добавил.
	*/
	addShip (ship, x, y) {
		// Если корабль уже присутствует на поле:
		if (this.ships.includes(ship)) {
			// Его уже не нужно добавлять.
			return false
		}

		// Добавить корабль.
		this.ships.push(ship)

		// Если корабль бросают в пределах игрового поля:
		if (this.inField(x, y)) {
			// Флаг - расположен ли корабль на игровом поле горизонтально?
			const dx = ship.direction === 'row'
			// Флаг - расположен ли корабль на игровом поле вертикально?
			const dy = ship.direction === 'column'

			/*
				Флаг - может ли корабль стать в ячейки?
				Изначально предположим, что да.
			*/
			let placed = true

			// Пройти по длине корабля (по всем его ячейкам).
			for (let i = 0; i < ship.size; i++) {
				// Координаты выбранной ячейки корабля.
				// Флаги dx, dy при умножении приводятся к 0 либо 1.
				const cx = x + dx * i
				const cy = y + dy * i

				/*
					Если одна из координат, где должен располагаться корабль,
					уходит за пределы игрового поля:
				*/
				if (!this.inField(cx, cy)) {
					// Корабль не сможет стать в ячейки.
					placed = false
					break
				}

				// Ячейка матрицы, в которой должен быть корабль.
				const item = this.matrix[cy][cx]
				// Если ячейка, в которую должен стать корабль, несвободна:
				if (!item.free) {
					// Корабль не сможет стать в ячейки.
					placed = false
					break
				}
			}

			// Если после проверок понятно, что корабль может стать в ячейки:
			if (placed) {
				// Положить корабль на игровое поле.
				Object.assign(ship, { x, y })
			}
		}

		// Поднять флаг, что на игровом поле изменились корабли.
		this._private_changed = true
		return true
	}

	/*
		Метод убирает переданный корабль с поля.
		Возвращает true, если удалил, false - если НЕ удалил.
	*/
	removeShip (ship) {
		// Если корабля нет на поле:
		if (!this.ships.includes(ship)) {
			// Удалять нечего
			return false
		}

		// Удалить корабль с поля.
		const index = this.ships.indexOf(ship)
		this.ships.splice(index, 1)

		// Удалить значения координат корабля.
		ship.x = null
		ship.y = null

		// Поднять флаг, что на игровом поле изменились корабли.
		this._private_changed = true
		return true
	}

	/*
		Метод убирает все корабли с поля
		и возвращает количество удалённых кораблей.
	*/
	removeAllShips () {
		// Копия массива всех кораблей.
		const ships = this.ships.slice()

		for (const ship of ships) {
			this.removeShip(ship)
		}

		// Вернуть количество удалённых кораблей.
		return ships.length
	}

	/*
		Метод добавляет переданный выстрел. Возвращает true, если удалось
		добавить выстрел, false - если НЕ удалось.
	*/
	addShot (shot) {
		// Пройти по координатам существующих выстрелов на игровом поле.
		for (const { x, y } of this.shots) {
			/*
				Если координаты переданного выстрела совпадают с координатами
				одного из уже существующих:
			*/
			if (x === shot.x && y === shot.y) {
				// Выстрел не может быть добавлен, потому что он уже есть.
				return false
			}
		}

		// Добавить выстрел в общий список всех выстрелов.
		this.shots.push(shot)
		// Поднять флаг, что на игровом поле изменились выстрелы.
		this._private_changed = true

		// Матрица игрового поля.
		const matrix = this.matrix
		// Координаты выстрела.
		const { x, y } = shot

		// Если в ячейке с выстрелом есть корабль:
		if (matrix[y][x].ship) {
			// Значит, попали в корабль.
			// Установить выстрелу состояние "ранение".
			shot.setVariant('wounded')

			// Корабль, раненый переданным выстрелом.
			const { ship } = matrix[y][x]
			// Флаг - расположен ли корабль на игровом поле горизонтально?
			const dx = ship.direction === 'row'
			// Флаг - расположен ли корабль на игровом поле вертикально?
			const dy = ship.direction === 'column'

			// Флаг - убит ли корабль? Предположим, что убит.
			let killed = true

			// Пройти по всем ячейкам корабля.
			for (let i = 0; i < ship.size; i++) {
				// Координаты выбранной ячейки.
				const cx = ship.x + dx * i
				const cy = ship.y + dy * i
				// Ячейка игрового поля с выбранной ячейкой корабля.
				const item = matrix[cy][cx]

				// Если выбранная ячейка не ранена:
				if (!item.wounded) {
					// Корабль ещё не убит (опустить флаг).
					killed = false
					break
				}
			}

			// Если корабль убит (все ячейки корабля ранены):
			if (killed) {
				// Отметить корабль убитым (поднять флаг).
				ship.killed = true

				// Пройти по всем ячейкам корабля.
				for (let i = 0; i < ship.size; i++) {
					// Координаты выбранной ячейки.
					const cx = ship.x + dx * i
					const cy = ship.y + dy * i

					// Выстрел по выбранной ячейке.
					const shot = this.shots
						.find(shot => shot.x === cx && shot.y === cy)
					// Установить выбранному выстрелу состояние - убийство.
					shot.setVariant('killed')

					// // Ячейка игрового поля с выбранной ячейкой корабля.
					// const item = matrix[cy][cx]

					// // Если выбранная ячейка не ранена:
					// if (!item.wounded) {
					// 	// Корабль ещё не убит (опустить флаг).
					// 	killed = false
					// 	break
					// }
				}

				// Установить выстрелу состояние "убийство".
				shot.setVariant('killed')
			}
		}

		// Поднять флаг, что на игровом поле изменились выстрелы.
		this._private_changed = true
		// Удалось добавить выстрел.
		return true
	}

	/*
		Метод удаляет переданный выстрел. Возвращает true, если удалось
		удалить выстрел, false - если нет.
	*/
	removeShot (shot) {
		// Если такого выстрела нет среди выстрелов:
		if (!this.shots.includes(shot)) {
			// Не удалось удалить выстрел.
			return false
		}

		// Если такой выстрел есть среди выстрелов:
		// Удалить переданный выстрел из выстрелов.
		const index = this.shots.indexOf(shot)

		this.shots.splice(index, 1)

		// Поднять флаг, что на игровом поле изменились выстрелы.
		this._private_changed = true
		return true
	}

	// Метод удаляет все выстрелы.
	removeAllShots () {
		// Копия массива всех выстрелов.
		const shots = this.shots.slice()
		for (const shot of shots) {
			this.removeShot(shot)
		}

		// Вернуть количество удалённых кораблей.
		return shots.length
	}

	/*
		Метод расставляет корабли на поле в случайном порядке.
		Принимает класс, который будет использоваться для создания кораблей
		(либо создать логический корабль, либо отображаемый).
	*/
	randomize (ShipClass = Ship) {
		// Удалить с поля все корабли.
		this.removeAllShips()

		// Пройти по всем размерам кораблей от большего к меньшему.
		for (let size = 4; size >= 1; size--) {
			// Пройти по всем кораблям выбранной длины.
			for (let n = 0; n < 5 - size; n++) {
				// Случайное направление корабля.
				const direction = getRandomFrom('row', 'column')
				// Новый корабль выбранного размера.
				const ship = new ShipClass(size, direction)

				// Пока корабль не размещён на поле:
				while (!ship.placed) {
					// Случайные координаты корабля.
					const x = getRandomBetween(0, 9)
					const y = getRandomBetween(0, 9)

					// Удалить корабль с поля.
					this.removeShip(ship)
					// Добавить этот же корабль с новыми координатами.
					this.addShip(ship, x, y)
				}
			}
		}
	}

	// Метод очищает игровое поле от кораблей и выстрелов.
	clear () {
		this.removeAllShots()
		this.removeAllShips()
	}
}